<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Account Tracker</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary: #000;
      --accent: #2563eb;
      --success: #10b981;
      --warning: #f59e0b;
      --danger: #ef4444;
      --background: #fafafa;
      --surface: #ffffff;
      --border: #e5e7eb;
      --text: #111827;
      --text-secondary: #6b7280;
      --text-light: #9ca3af;
      --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
      --radius: 8px;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', system-ui, sans-serif;
      background: var(--background);
      color: var(--text);
      line-height: 1.5;
      padding-top: 50px;
      font-size: 14px;
    }

    .container {
      max-width: 428px;
      margin: 0 auto;
      background: var(--surface);
      min-height: 100vh;
    }

    .header {
      text-align: center;
      margin-bottom: 24px;
    }

    .header-title {
      font-size: 24px;
      font-weight: 600;
      color: #1a202c;
      margin-bottom: 8px;
    }

    /* Navigation */
    .mobile-nav {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      background: var(--surface);
      border-bottom: 1px solid var(--border);
      z-index: 1000;
      padding: 8px 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      height: 50px;
    }

    .nav-brand {
      font-weight: 600;
      font-size: 16px;
      color: var(--text);
    }

    .nav-toggle {
      background: none;
      border: none;
      font-size: 18px;
      cursor: pointer;
      padding: 4px;
      color: var(--text-secondary);
    }

    .nav-menu {
      position: fixed;
      top: 50px;
      left: 0;
      width: 100%;
      background: var(--surface);
      border-bottom: 1px solid var(--border);
      padding: 8px;
      display: none;
      z-index: 999;
    }

    .nav-menu.active {
      display: block;
    }

    .nav-link {
      display: flex;
      align-items: center;
      padding: 10px 12px;
      text-decoration: none;
      color: var(--text-secondary);
      border-radius: 6px;
      transition: all 0.2s;
      font-weight: 500;
      font-size: 14px;
      margin-bottom: 2px;
    }

    .nav-link.active {
      background: var(--accent);
      color: white;
    }

    .nav-icon {
      margin-right: 8px;
      width: 16px;
      text-align: center;
    }



    .balance-section {
      background: white;
      border-radius: 12px;
      padding: 24px;
      margin-bottom: 16px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      text-align: center;
    }

    .balance-label {
      font-size: 14px;
      color: #64748b;
      margin-bottom: 8px;
    }

    .balance-amount {
      font-size: 32px;
      font-weight: 600;
      color: #1a202c;
    }

    .add-button {
      width: 100%;
      background: #10b981;
      color: white;
      border: none;
      border-radius: 8px;
      padding: 16px;
      font-size: 16px;
      font-weight: 500;
      cursor: pointer;
      margin-bottom: 16px;
      transition: background 0.2s ease;
    }

    .add-button:hover {
      background: #059669;
    }

    .form-card {
      background: white;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 16px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      display: none;
    }

    .form-card.show {
      display: block;
    }

    .form-grid {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 12px;
      margin-bottom: 16px;
    }

    .input-group {
      display: flex;
      flex-direction: column;
    }

    .input-label {
      font-size: 12px;
      font-weight: 500;
      color: #64748b;
      margin-bottom: 4px;
    }

    .form-input {
      padding: 12px;
      border: 1px solid #e2e8f0;
      border-radius: 6px;
      font-size: 14px;
      transition: border-color 0.2s ease;
    }

    .form-input:focus {
      outline: none;
      border-color: #10b981;
    }

    .form-controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-bottom: 16px;
    }

    .control-group {
      display: flex;
      flex-direction: column;
    }

    .control-label {
      font-size: 12px;
      font-weight: 500;
      color: #64748b;
      margin-bottom: 6px;
    }

    .selection-group {
      display: flex;
      gap: 4px;
    }

    .selection-option {
      flex: 1;
      padding: 8px 12px;
      border: 1px solid #e2e8f0;
      border-radius: 6px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s ease;
      background: white;
      font-size: 12px;
      font-weight: 500;
    }

    .selection-option:hover {
      border-color: #cbd5e1;
    }

    .selection-option.active {
      border-color: #10b981;
      background: #10b981;
      color: white;
    }

    .submit-btn {
      width: 100%;
      background: #3b82f6;
      color: white;
      border: none;
      border-radius: 6px;
      padding: 12px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.2s ease;
    }

    .submit-btn:hover {
      background: #2563eb;
    }

    .filter-tabs {
      display: flex;
      background: white;
      border-radius: 8px;
      padding: 4px;
      margin-bottom: 16px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .filter-tab {
      flex: 1;
      padding: 8px 12px;
      text-align: center;
      background: transparent;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      color: #64748b;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .filter-tab.active {
      background: #3b82f6;
      color: white;
    }

    .transactions-list {
      background: white;
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      margin-bottom: 16px;
    }

    .transaction-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 0;
      border-bottom: 1px solid #f1f5f9;
    }

    .transaction-item:last-child {
      border-bottom: none;
    }

    .transaction-left {
      flex: 1;
    }

    .transaction-right {
      text-align: right;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 4px;
    }

    .transaction-name {
      font-size: 16px;
      font-weight: 600;
      color: #1a202c;
      margin-bottom: 4px;
    }

    .transaction-type {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      margin-bottom: 4px;
    }

    .transaction-type.credit {
      background: #dcfce7;
      color: #166534;
    }

    .transaction-type.debit {
      background: #fee2e2;
      color: #991b1b;
    }

    .transaction-amount {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 2px;
    }

    .transaction-amount.credit {
      color: #10b981;
    }

    .transaction-amount.debit {
      color: #ef4444;
    }

    .transaction-balance {
      font-size: 12px;
      color: #64748b;
    }

    .transaction-meta {
      font-size: 12px;
      color: #64748b;
      margin-top: 4px;
    }

    .transaction-method  {
      display: inline-block;
      background: #f1f5f9;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 500;
      margin-right: 8px;
    }
    .transaction-id-time{
            display: inline-block;
      background: #f1f5f9;
      padding: 1px 3px;
      border-radius: 2px;
      font-size: 8px;
      font-weight: 500;
      margin-right: 4px;
    }
    .load-more-btn {
      width: 100%;
      background: #f1f5f9;
      color: #64748b;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      padding: 12px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      margin-bottom: 16px;
      transition: all 0.2s ease;
    }

    .load-more-btn:hover {
      background: #e2e8f0;
    }

    .load-more-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .no-transactions {
      text-align: center;
      padding: 40px 20px;
      color: #64748b;
    }

    .loading {
      text-align: center;
      padding: 20px;
      color: #64748b;
    }

    .cache-info {
      background: white;
      border-radius: 8px;
      padding: 12px;
      text-align: center;
      font-size: 11px;
      color: #64748b;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .cache-status {
      display: inline-block;
      padding: 2px 6px;
      background: #dcfce7;
      color: #166534;
      border-radius: 4px;
      margin-left: 4px;
      font-size: 10px;
    }
  </style>
</head>

<body>

  <nav class="mobile-nav">
    <div class="nav-brand">Account Details</div>
    <button class="nav-toggle" id="navToggle">‚ò∞</button>
    <ul class="nav-menu" id="navMenu">
      <li><a href="index.html" class="nav-link"><span class="nav-icon">üí∞</span>Expenses</a></li>
      <li><a href="lend.html" class="nav-link"><span class="nav-icon">ü§ù</span>Lend Records</a></li>
      <li><a href="account.html" class="nav-link active"><span class="nav-icon">ü™™</span>Account Details</a></li>
      <li><a href="borrow.html" class="nav-link"><span class="nav-icon">üè¶</span>Borrow Details</a></li>
    </ul>
  </nav>





  <div class="container">
    <div class="header">
      <h1 class="header-title">Account Tracker</h1>
    </div>

    <div class="balance-section">
      <div class="balance-label">Current Balance</div>
      <div class="balance-amount" id="currentBalance">‚Çπ0.00</div>
    </div>

    <button id="toggleFormBtn" class="add-button">Add Transaction</button>

    <div id="transactionForm" class="form-card">
      <div class="form-grid">
        <div class="input-group">
          <label class="input-label">Description</label>
          <input type="text" id="description" class="form-input" placeholder="Enter description" />
        </div>
        <div class="input-group">
          <label class="input-label">Amount (‚Çπ)</label>
          <input type="number" id="amount" class="form-input" placeholder="0.00" step="0.01" />
        </div>
      </div>

      <div class="form-controls">
        <div class="control-group">
          <div class="control-label">Type</div>
          <div class="selection-group">
            <div class="selection-option" data-value="credit">Credit</div>
            <div class="selection-option active" data-value="debit">Debit</div>
          </div>
        </div>
        <div class="control-group">
          <div class="control-label">Method</div>
          <div class="selection-group">
            <div class="selection-option" data-value="Cash">Cash</div>
            <div class="selection-option active" data-value="UPI">UPI</div>
          </div>
        </div>
      </div>

      <button id="addBtn" class="submit-btn">Add Transaction</button>
    </div>

    <div class="filter-tabs">
      <button class="filter-tab active" data-filter="all">All</button>
      <button class="filter-tab" data-filter="credit">Credit</button>
      <button class="filter-tab" data-filter="debit">Debit</button>
    </div>

    <div class="transactions-list">
      <div id="transactionsList">
        <div class="loading">Loading transactions...</div>
      </div>
    </div>

    <button id="loadMoreBtn" class="load-more-btn" style="display: none;">
      Load More Transactions
    </button>

    <div class="cache-info">
      <span id="cacheInfo">Cache: Not loaded</span>
    </div>
  </div>

  <!-- Load Firebase SDKs -->
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>

  <script>
    // Initialize Firebase
    const firebaseConfig = {
      apiKey: "AIzaSyAk6-ojS17WvRyCn-4mqQgOxRtk6aa1hAc",
      authDomain: "nutritiontracker-56702.firebaseapp.com",
      projectId: "nutritiontracker-56702",
      storageBucket: "nutritiontracker-56702.appspot.com",
      messagingSenderId: "670664900798",
      appId: "1:670664900798:web:f4e0104661ddd985b81eef",
      measurementId: "G-GLNQXTX2SY"
    };

    firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();


    // Navigation
    const navToggle = document.getElementById('navToggle');
    const navMenu = document.getElementById('navMenu');

    navToggle.addEventListener('click', () => {
      navMenu.classList.toggle('active');
    });

    document.addEventListener('click', (e) => {
      if (!navToggle.contains(e.target) && !navMenu.contains(e.target)) {
        navMenu.classList.remove('active');
      }
    });
    // Cache management
    const CACHE_DURATION = 6 * 60 * 60 * 1000; // 6 hours in milliseconds
    const TRANSACTIONS_PER_PAGE = 15;

    let transactionCache = {
      data: [],
      timestamp: null,
      oldestCachedId: null,
      newestCachedId: null,
      hasMoreOld: true
    };

    let currentBalance = 0;
    let isLoadingMore = false;
    let currentFilter = 'all';

    // Extract transaction number from ID (e.g., "tnx_45" -> 45)
    function getTransactionNumber(transactionId) {
      const match = transactionId.match(/tnx_(\d+)/);
      return match ? parseInt(match[1]) : 0;
    }

    // Check if cache is valid
    function isCacheValid() {
      if (!transactionCache.timestamp) return false;
      const now = Date.now();
      const cacheAge = now - transactionCache.timestamp;
      return cacheAge < CACHE_DURATION;
    }

    // Update cache info display
    function updateCacheInfo() {
      const cacheInfoEl = document.getElementById('cacheInfo');
      if (transactionCache.data.length > 0) {
        const oldest = transactionCache.oldestCachedId;
        const newest = transactionCache.newestCachedId;
        const cacheAge = transactionCache.timestamp ?
          Math.round((Date.now() - transactionCache.timestamp) / (1000 * 60)) : 0;

        cacheInfoEl.innerHTML = `
          Cache: ${oldest} to ${newest} 
          <span class="cache-status">${cacheAge}m old</span>
        `;
      } else {
        cacheInfoEl.textContent = 'Cache: Empty';
      }
    }

    // Fetch recent transactions and update cache
    async function fetchRecentTransactions() {
      try {
        console.log('Fetching recent transactions...');

        // Get the latest 15 transactions
        const snapshot = await db.collection("account")
          .orderBy("timestamp", "desc")
          .limit(TRANSACTIONS_PER_PAGE)
          .get();

        const transactions = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        }));

        // Update cache
        transactionCache.data = transactions;
        transactionCache.timestamp = Date.now();

        if (transactions.length > 0) {
          // Sort by transaction number to find oldest and newest
          const sortedByNumber = transactions.sort((a, b) =>
            getTransactionNumber(b.id) - getTransactionNumber(a.id)
          );

          transactionCache.newestCachedId = sortedByNumber[0].id;
          transactionCache.oldestCachedId = sortedByNumber[sortedByNumber.length - 1].id;

          // Check if there are more older transactions
          const oldestNumber = getTransactionNumber(transactionCache.oldestCachedId);
          transactionCache.hasMoreOld = oldestNumber > 1;
        } else {
          transactionCache.newestCachedId = null;
          transactionCache.oldestCachedId = null;
          transactionCache.hasMoreOld = false;
        }

        console.log('Cache updated:', {
          count: transactions.length,
          oldest: transactionCache.oldestCachedId,
          newest: transactionCache.newestCachedId,
          hasMore: transactionCache.hasMoreOld
        });

        return transactions;
      } catch (error) {
        console.error("Error fetching recent transactions:", error);
        return [];
      }
    }

    // Fetch newer transactions since last cached
    async function fetchNewerTransactions() {
      if (!transactionCache.newestCachedId) return [];

      try {
        console.log('Fetching newer transactions since:', transactionCache.newestCachedId);

        const newestNumber = getTransactionNumber(transactionCache.newestCachedId);

        // Get all transactions with ID higher than cached newest
        const snapshot = await db.collection("account").get();

        const newerTransactions = snapshot.docs
          .map(doc => ({ id: doc.id, ...doc.data() }))
          .filter(tx => getTransactionNumber(tx.id) > newestNumber)
          .sort((a, b) => getTransactionNumber(b.id) - getTransactionNumber(a.id));

        console.log('Found newer transactions:', newerTransactions.length);

        if (newerTransactions.length > 0) {
          // Add newer transactions to beginning of cache
          transactionCache.data = [...newerTransactions, ...transactionCache.data];
          transactionCache.newestCachedId = newerTransactions[0].id;

          // Keep only latest 15 in cache
          if (transactionCache.data.length > TRANSACTIONS_PER_PAGE) {
            transactionCache.data = transactionCache.data.slice(0, TRANSACTIONS_PER_PAGE);
            transactionCache.oldestCachedId = transactionCache.data[transactionCache.data.length - 1].id;
          }

          transactionCache.timestamp = Date.now();
        }

        return newerTransactions;
      } catch (error) {
        console.error("Error fetching newer transactions:", error);
        return [];
      }
    }

    // Fetch older transactions for pagination
    async function fetchOlderTransactions() {
      if (!transactionCache.oldestCachedId || !transactionCache.hasMoreOld) return [];

      try {
        console.log('Fetching older transactions before:', transactionCache.oldestCachedId);

        const oldestNumber = getTransactionNumber(transactionCache.oldestCachedId);

        // Get transactions with ID lower than cached oldest
        const snapshot = await db.collection("account").get();

        const olderTransactions = snapshot.docs
          .map(doc => ({ id: doc.id, ...doc.data() }))
          .filter(tx => getTransactionNumber(tx.id) < oldestNumber)
          .sort((a, b) => getTransactionNumber(b.id) - getTransactionNumber(a.id))
          .slice(0, TRANSACTIONS_PER_PAGE);

        console.log('Found older transactions:', olderTransactions.length);

        if (olderTransactions.length > 0) {
          // Add older transactions to end of cache
          transactionCache.data = [...transactionCache.data, ...olderTransactions];
          transactionCache.oldestCachedId = olderTransactions[olderTransactions.length - 1].id;

          // Check if there are more older transactions
          const newOldestNumber = getTransactionNumber(transactionCache.oldestCachedId);
          transactionCache.hasMoreOld = newOldestNumber > 1;
        } else {
          transactionCache.hasMoreOld = false;
        }

        return olderTransactions;
      } catch (error) {
        console.error("Error fetching older transactions:", error);
        return [];
      }
    }

    // Form management
    function toggleForm() {
      const form = document.getElementById('transactionForm');
      const toggleBtn = document.getElementById('toggleFormBtn');

      if (form.classList.contains('show')) {
        form.classList.remove('show');
        toggleBtn.textContent = 'Add Transaction';
        clearForm();
      } else {
        form.classList.add('show');
        toggleBtn.textContent = 'Cancel';
      }
    }

    function clearForm() {
      document.getElementById("description").value = "";
      document.getElementById("amount").value = "";

      // Reset selections
      document.querySelectorAll('.selection-option').forEach(option => {
        option.classList.remove('active');
      });

      // Set defaults
      document.querySelector('[data-value="debit"]').classList.add('active');
      document.querySelector('[data-value="UPI"]').classList.add('active');
    }

    function setupSelections() {
      document.querySelectorAll('.selection-group').forEach(group => {
        group.addEventListener('click', (e) => {
          const option = e.target.closest('.selection-option');
          if (!option) return;

          // Remove active from siblings
          group.querySelectorAll('.selection-option').forEach(opt => {
            opt.classList.remove('active');
          });

          // Add active to clicked option
          option.classList.add('active');
        });
      });
    }

    function getSelectedValues() {
      const typeOption = document.querySelector('.selection-group .selection-option.active[data-value="credit"], .selection-group .selection-option.active[data-value="debit"]');
      const methodOption = document.querySelector('.selection-group .selection-option.active:not([data-value="credit"]):not([data-value="debit"])');

      return {
        type: typeOption ? typeOption.dataset.value : 'debit',
        method: methodOption ? methodOption.dataset.value : 'UPI'
      };
    }

    // Filter setup
    function setupFilters() {
      document.querySelectorAll('.filter-tab').forEach(tab => {
        tab.addEventListener('click', (e) => {
          // Remove active from all tabs
          document.querySelectorAll('.filter-tab').forEach(t => t.classList.remove('active'));

          // Add active to clicked tab
          e.target.classList.add('active');

          // Update current filter
          currentFilter = e.target.dataset.filter;

          // Re-render transactions with filter
          renderTransactions(transactionCache.data);
        });
      });
    }

    // Filter transactions based on current filter
    function filterTransactions(transactions) {
      if (currentFilter === 'all') return transactions;
      return transactions.filter(tx => tx.type === currentFilter);
    }

    // Get the next incremental transaction ID
    async function getNextTransactionId() {
      try {
        const counterRef = db.collection('counters').doc('transactionCounter');

        // First, try to get existing counter
        const counterDoc = await counterRef.get();

        if (counterDoc.exists) {
          const currentCount = counterDoc.data().count;
          const newCount = currentCount + 1;

          // Update counter
          await counterRef.update({ count: newCount });
          console.log('Generated ID:', `tnx_${newCount}`);
          return `tnx_${newCount}`;
        } else {
          // Initialize counter with 1
          await counterRef.set({ count: 1 });
          console.log('Generated ID: tnx_1');
          return 'tnx_1';
        }
      } catch (error) {
        console.error('Error in getNextTransactionId:', error);

        // Simple fallback - just get count of existing documents + 1
        try {
          const snapshot = await db.collection('account').get();
          const nextId = snapshot.size + 1;
          console.log('Fallback generated ID:', `tnx_${nextId}`);
          return `tnx_${nextId}`;
        } catch (fallbackError) {
          console.error('Fallback also failed:', fallbackError);
          // Last resort - use a simple number
          const simpleId = Math.floor(Math.random() * 100) + 1;
          return `tnx_${simpleId}`;
        }
      }
    }

    // Calculate running balance using database update_bal
    function calculateRunningBalance(transactions) {
      // Sort by timestamp ascending to get chronological order
      const sortedTransactions = [...transactions].sort((a, b) =>
        a.timestamp.toMillis() - b.timestamp.toMillis()
      );

      // Use the update_bal from database if available, otherwise calculate
      let runningBalance = 0;
      const updatedTransactions = [];

      sortedTransactions.forEach((tx, index) => {
        if (tx.update_bal !== undefined && tx.update_bal !== null) {
          // Use database update_bal
          runningBalance = parseFloat(tx.update_bal) || 0;
        } else {
          // Fallback calculation if update_bal is missing
          const amount = parseFloat(tx.amount) || 0;
          runningBalance += tx.type === 'credit' ? amount : -amount;
        }

        updatedTransactions.push({
          ...tx,
          update_bal: runningBalance
        });
      });

      // Update current balance to the latest transaction's balance
      if (updatedTransactions.length > 0) {
        currentBalance = updatedTransactions[updatedTransactions.length - 1].update_bal;
      } else {
        currentBalance = 0;
      }

      // Sort back to descending for display (newest first by timestamp)
      return updatedTransactions.sort((a, b) =>
        b.timestamp.toMillis() - a.timestamp.toMillis()
      );
    }

    // Render transactions
    function renderTransactions(transactions, append = false) {
      const listEl = document.getElementById("transactionsList");

      if (!append) {
        listEl.innerHTML = "";
      }

      if (transactions.length === 0 && !append) {
        listEl.innerHTML = '<div class="no-transactions">No transactions yet. Add your first transaction above!</div>';
        currentBalance = 0;
        document.getElementById("currentBalance").innerText = "‚Çπ0.00";
        updateLoadMoreButton();
        return;
      }

      const transactionsWithBalance = calculateRunningBalance(transactionCache.data);

      // Apply current filter
      const filteredTransactions = filterTransactions(transactionsWithBalance);

      // If appending, only render the new transactions
      const transactionsToRender = append ?
        filteredTransactions.filter(tx =>
          transactions.some(newTx => newTx.id === tx.id)
        ) : filteredTransactions;

      transactionsToRender.forEach(tx => {
        const div = document.createElement("div");
        div.className = `transaction-item`;
        div.setAttribute('data-tx-id', tx.id);

        const amount = parseFloat(tx.amount) || 0;
        const sign = tx.type === 'credit' ? '+' : '';
        const formattedAmount = `${sign}‚Çπ${amount.toFixed(2)}`;
        //----------------Test-----------------------------------
        function formatDateTime(timestamp) {
          if (!timestamp) return '';
          const dateObj = timestamp.toDate();
          const options = {
            month: 'short', day: 'numeric',
            hour: '2-digit', minute: '2-digit', hour12: true,
            timeZone: 'Asia/Kolkata'
          };
          return dateObj.toLocaleString('en-IN', options);
        }

        //---------------------------------Test--------------------------------
        div.innerHTML = `
          <div class="transaction-left">
            <div class="transaction-name">${tx.description || 'No description'}</div>
            <div class="transaction-type ${tx.type}">${tx.type}</div>
            <div class="transaction-meta">
              <span class="transaction-method">${tx.method}</span>
              <span class="transaction-id-time">${tx.id}
                | ‚Ä¢ ${formatDateTime(tx.timestamp)} </span>
            </div>
          </div>
          <div class="transaction-right">
            <div class="transaction-amount ${tx.type}">${formattedAmount}</div>
            <div class="transaction-balance">Balance: ‚Çπ${(tx.update_bal || 0).toFixed(2)}</div>
          </div>
        `;

        listEl.appendChild(div);
      });

      // Update current balance using the most recent transaction's update_bal
      if (transactionsWithBalance.length > 0) {
        // Sort by timestamp to get the most recent transaction
        const sortedByTime = transactionsWithBalance.sort((a, b) =>
          b.timestamp.toMillis() - a.timestamp.toMillis()
        );
        currentBalance = sortedByTime[0].update_bal || 0;
      } else {
        currentBalance = 0;
      }

      console.log('Current balance updated to:', currentBalance);
      document.getElementById("currentBalance").innerText = `‚Çπ${currentBalance.toFixed(2)}`;

      updateLoadMoreButton();
      updateCacheInfo();
    }

    // Update load more button state
    function updateLoadMoreButton() {
      const loadMoreBtn = document.getElementById('loadMoreBtn');

      if (transactionCache.hasMoreOld && transactionCache.data.length >= TRANSACTIONS_PER_PAGE) {
        loadMoreBtn.style.display = 'block';
        loadMoreBtn.disabled = isLoadingMore;
        loadMoreBtn.textContent = isLoadingMore ? 'Loading...' : 'Load More Transactions';
      } else {
        loadMoreBtn.style.display = 'none';
      }
    }

    // Load initial transactions
    async function loadInitialTransactions() {
      try {
        let transactions = [];

        if (isCacheValid()) {
          console.log('Using valid cache, checking for newer transactions...');
          // Check for newer transactions
          const newerTx = await fetchNewerTransactions();
          if (newerTx.length > 0) {
            console.log('Found newer transactions, updating display...');
          }
          transactions = transactionCache.data.slice(0, TRANSACTIONS_PER_PAGE);
        } else {
          console.log('Cache invalid or empty, fetching fresh data...');
          transactions = await fetchRecentTransactions();
        }

        renderTransactions(transactions);
      } catch (error) {
        console.error("Error loading initial transactions:", error);
        document.getElementById("transactionsList").innerHTML =
          '<div class="no-transactions">Error loading transactions. Please refresh the page.</div>';
      }
    }

    // Load more transactions
    async function loadMoreTransactions() {
      if (isLoadingMore || !transactionCache.hasMoreOld) return;

      isLoadingMore = true;
      updateLoadMoreButton();

      try {
        const olderTx = await fetchOlderTransactions();
        if (olderTx.length > 0) {
          renderTransactions(olderTx, true);
        }
      } catch (error) {
        console.error("Error loading more transactions:", error);
        alert("Failed to load more transactions. Please try again.");
      } finally {
        isLoadingMore = false;
        updateLoadMoreButton();
      }
    }

    // Real-time listener for new transactions only
    function setupRealtimeListener() {
      console.log('Setting up realtime listener...');

      // Listen only for the most recent transactions to catch new additions
      db.collection("account")
        .orderBy("timestamp", "desc")
        .limit(3) // Only watch the last 3 transactions for new additions
        .onSnapshot(async (snapshot) => {
          console.log('Realtime update detected...');

          if (transactionCache.data.length === 0) {
            // If no cache, load initial transactions
            await loadInitialTransactions();
            return;
          }

          // Check if there are any new transactions
          const latestDocs = snapshot.docs.map(doc => ({
            id: doc.id,
            ...doc.data()
          }));

          const newestCachedNumber = getTransactionNumber(transactionCache.newestCachedId || 'tnx_0');
          const hasNewTransactions = latestDocs.some(tx =>
            getTransactionNumber(tx.id) > newestCachedNumber
          );

          if (hasNewTransactions) {
            console.log('New transactions detected, refreshing...');
            await fetchNewerTransactions();
            renderTransactions(transactionCache.data.slice(0, TRANSACTIONS_PER_PAGE));
          }
        }, error => {
          console.error("Error in realtime listener:", error);
        });
    }

    // Add transaction
    async function addTransaction() {
      const description = document.getElementById("description").value.trim();
      const amount = parseFloat(document.getElementById("amount").value);
      const selections = getSelectedValues();

      // Validation
      if (!description) {
        alert("Description cannot be empty.");
        return;
      }
      if (isNaN(amount) || amount <= 0) {
        alert("Please enter a valid positive amount.");
        return;
      }

      try {
        // Get the incremental transaction ID
        const transactionId = await getNextTransactionId();
        console.log('Using transaction ID:', transactionId);

        // Calculate new balance based on current balance
        const newBalance = currentBalance + (selections.type === 'credit' ? amount : -amount);

        // Generate linked_expense_id (date-based format like your example)
        const now = new Date();
        const dateStr = now.toLocaleDateString('en-GB').replace(/\//g, '-');
        const timeStr = Math.floor(Math.random() * 10); // Random digit for uniqueness
        const linkedExpenseId = `${dateStr}_${timeStr}`;

        // Add transaction with all fields matching your database structure
        const transactionData = {
          amount: amount,
          auto_created: false, // Manual entry
          description: description,
          linked_expense_id: linkedExpenseId,
          method: selections.method,
          timestamp: firebase.firestore.Timestamp.now(),
          type: selections.type,
          update_bal: newBalance
        };

        await db.collection("account").doc(transactionId).set(transactionData);

        console.log('Transaction added successfully:', {
          id: transactionId,
          data: transactionData
        });

        // Clear form and hide it
        clearForm();
        toggleForm();

      } catch (error) {
        console.error("Error adding transaction:", error);
        alert("Failed to add transaction. Please try again.");
      }
    }

    // Event listeners
    window.onload = () => {
      document.getElementById("toggleFormBtn").addEventListener("click", toggleForm);
      document.getElementById("addBtn").addEventListener("click", addTransaction);
      document.getElementById("loadMoreBtn").addEventListener("click", loadMoreTransactions);

      // Setup selection groups and filters
      setupSelections();
      setupFilters();

      // Add enter key support for inputs
      document.getElementById("description").addEventListener("keypress", (e) => {
        if (e.key === "Enter") addTransaction();
      });
      document.getElementById("amount").addEventListener("keypress", (e) => {
        if (e.key === "Enter") addTransaction();
      });

      // Load initial transactions and setup realtime listener
      loadInitialTransactions();
      setupRealtimeListener();

      // Update cache info every minute
      setInterval(updateCacheInfo, 60000);
    };
  </script>
</body>

</html>